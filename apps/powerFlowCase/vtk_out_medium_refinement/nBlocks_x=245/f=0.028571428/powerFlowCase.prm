options
{
   // Only one of the two options below can be set to true
   writeSetupForestAndReturn false;  // If set to true, the blocks in the domain will be output in a vtk file. The simulation will be terminated after this to save memory
   writeVoxelfile false;            // If set to true, the voxels in the domain will be output in a vtk file. The simulation will be terminated after this to save memory
}

flowParameters
{ 
    velocityMagnitude 1;           // [m/s] Absolute velocity of the flow 
    angleOfAttack 0.0;              // [deg] Angle of attack of the flow with respect to the airfoil  
}

simulationParameters
{
    omega 1.6                       // Relaxation factor for the SRT model
    timeSteps   100000;              // Number of time steps in the simulation
    remainingTimeLoggerFrequency 3; // in seconds. This is the frequency with which a time estimate of finilising the simulation is send in the terminal. 

}

domainParameters
{
    meshFile         NACA0018.stl;   		 // Object geometry of the airfoil. This must be an ASCII file. If it is binary you should convert it. Also, the mesh must be watertight so no open sides. 
    meshZScaling     1; // 0.0625;                    // This factor can be used to change the span of the airfoil. The NACA0018 file has a span of 0.081625 which corresponds to a y-scaling of 1
    
    numLevels        5;                  	 // Number of octree levels starting from 1
    dx               0.0051015625;          // Unrefined cell size in mm since the airfoil dimensions are in meters
    scalePowerFlowDomain true;          	 // Do you want the full PowerFlow domain. If not, set to false and define an own domainScaling
    
    decreasePowerFlowDomainFactor 0.028571428;		 // Set to 1 if the full domain is desired. Change the number of cells in a block accordingly
    // xyAdjuster 1.000691106;                // Adjust the domain x and z dimension to have a better cell fit.
    // domainScaling    <  100, 1, 600 >;   	 // Scaling of the domain compared to the object.  So < 100, 1, 556 > means 100 times the chord of the airfoil, 1 time the span and 556 times the thickness. 
    cellsPerBlock    <  20, 20, 16 >;       	 // Number of cells in each block in the < x, y, z > directions. This is also called blockSize in some codes. For refinement at least < 16, 16, 16 > is required
    periodic         <  0, 0, 1 >;       	 // Are there period sides? 0 -> No, 1 -> Yes  For every direction < x, y, z >
    numGhostLayers   4;

}

boundaryConditions 
{
	velocity0 < 1, 0, 0 >;        // velocity of cells where Velocity0 boundary is set
	velocity1 <   0, 0, 0 >;        // velocity of cells where Velocity1 boundary is set
	pressure0 1.01;		            // pressure of cells where Pressure0 boundary is set
	pressure1 1.0;			        // pressure of cells where Pressure1 boundary is set
    
    /* 
       possible sub-blocks: documentation for the subblocks can be found in src/geometry/initializers/BoundaryFrom*.h
       	   - CellInterval	 BoundaryFromCellInterval.h
       	   - Border          BoundaryFromDomainBorder.h
       	   - VoxelFile	     BoundaryFromVoxelFile.h
       	   - Body			 BoundaryFromBody.h
       	   - GrayScaleImage  BoundaryFromImage.h
       	   - RGBAImage	     BoundaryFromImage.h
    */
    
	Border { direction W;    walldistance -1;  Velocity0 {} }
	Border { direction E;    walldistance -1;  Pressure1 {} }
	Border { direction S,N;  walldistance -1;  Pressure1 {} }
		
}

// Parameters for the stability check. If NaN values occur, the simululation is terminated. 
stabilityChecker
{
   checkFrequency 1;
   streamOutput   true;
   vtkOutput      false;
}

VTK 
{
   // for parameter documentation see src/vtk/Initialization.cpp
   fluid_field
   {
      writeFrequency 100000000;           // [time steps] Output a VTK file at writeFrequency
      ghostLayers    4;             // Number of ghostlayers to exclude from the VTK output
      
      vtkBeforFunctions {
         PDFGhostLayerSync;
      }
      
      vtkInclusionFilters {
         DomainFilter;
      }
      
      vtkWriters {
         Velocity;
         // Density;
         // Pressure;
      }
   }
   
   vtkFlagField
   {
      writeFrequency 1000000000; // write only once
      ghostLayers    4;
      
      writers {
         FlagField;
      }
   }
   
   vtkDomainDecomposition
   {
      writeFrequency 1000000000;           // write only once
      outputDomainDecomposition true;
   }
}

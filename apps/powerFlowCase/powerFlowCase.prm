options
{
   writeSetupForestAndReturn false;    // If set to true, the blocks in the domain will be output in a vtk file. The simulation will be terminated after this to save memory
   writeVoxelfile false;               // If set to true, the voxels in the domain will be output in a vtk file. The simulation will be terminated after this to save memory
   writeAirfoilMeshAndReturn false;    // If set true the airfoil stl mesh is written in a vtu file. The simulation will be terminated after this to save memory
   writeSimulationSetupAndUnits true;  // Write the file with the simulation setup and unit conversion

   useTurbulenceModel true;            // Use a turbulence model to simulate the effect of the small unresolved turbulence scales on the larger refined scales (provide stability)
}

flowParameters
{ 
   angleOfAttack 0.0;               // [deg] Physical angle of attack of the flow with respect to the airfoil  
   velocityMagnitudeSI 20;          // [m/s] Physical absolute velocity of the flow
   initialVelocityMagnitudeSI 0; 
   kinViscositySI 1.461e-05;        // [m2/s] Physical kinematic viscosity of the flow
   rhoSI 1.225;                     // [kg/m3] Physical air density
   temperatureSI 288.1;             // [K] Temperature
}

simulationParameters
{
   omega 1.99994;                      // Relaxation factor for the SRT model
   timeSteps   3;                   // Number of time steps in the simulation
   remainingTimeLoggerFrequency 120;   // in seconds. This is the frequency with which a time estimate of finilising the simulation is send in the terminal. 
   smagorinskyConstant 0.12;           // Smagorinsky constant for the Smagorinky LES turbulence model
}

domainParameters
{
    meshFile         NACA0018.stl;   		      // Object geometry of the airfoil. This must be an ASCII file. If it is binary you should convert it. Also, the mesh must be watertight so no open sides. 
    scalePowerFlowDomain true;          	      // Do you want the full PowerFlow domain. If not, set to false and define an own 'domainScaling'
    decreasePowerFlowDomainFactor 0.142857142; // 0.028571428;  // Set to 1 if the full domain is desired. Change the number of cells in a block accordingly
    dxSI               0.0051015625;            // Unrefined cell size in mm since the airfoil dimensions are in meters
    numLevels        3;                  	      // Number of octree levels starting from 1
    meshZScaling     1;                         // This factor can be used to change the span of the airfoil. The NACA0018 file has a span of 0.081625 which corresponds to a y-scaling of 1
    numGhostLayers   4;                         // Number of ghost layers on each block. Used for communication (overlap) and boundary conditions.

}

spongeZoneParameters
{
   spongeInnerThicknessFactor 0.5;     // inner radius factor of the sponge layer >> r_inner = factor * max(L/2, H/2)
   spongeOuterThicknessFactor 0.75;    // outer radius factor of the sponge layer >> r_outer = factor * max(L/2, H/2)
   sponge_nuT_min 0.0;                 // minimum value of additional numerical viscosity in the sponge layer. This is a factor and multiplied with the base viscosity of the fluid
   sponge_nuT_max 0.5;                 // maximum value of additional numerical viscosity in the sponge layer. This is a factor and multiplied with the base viscosity of the fluid
}

boundaryConditions 
{
   periodicity         <  0, 0, 1 >;       	         // Are there period sides? 0 -> No, 1 -> Yes  For every direction < x, y, z >

   velocity0 < 0.0339296, 0, 0 >;                   // velocity of cells where Velocity0 boundary is set (aoa = 0 deg)
	velocity1 < 0.033909, 0.00118413, 0>;    // velocity of cells where Velocity1 boundary is set (aoa = 2 deg)
	pressure0 1.01;		                           // pressure of cells where Pressure0 boundary is set
	pressure1 1.0;			                           // pressure of cells where Pressure1 boundary is set
    
	Border { direction N,S,W;    walldistance -1;  Velocity0 {} }     // Inflow walls
	Border { direction E;    walldistance -1;  Pressure1 {} }         // Outflow wall

      /* 
      possible sub-blocks: documentation for the subblocks can be found in src/geometry/initializers/BoundaryFrom*.h
         - CellInterval	 BoundaryFromCellInterval.h
         - Border          BoundaryFromDomainBorder.h
         - VoxelFile	     BoundaryFromVoxelFile.h
         - Body			 BoundaryFromBody.h
         - GrayScaleImage  BoundaryFromImage.h
         - RGBAImage	     BoundaryFromImage.h
   */
}

// Parameters for the stability check. If NaN values occur, the simululation is terminated. 
stabilityChecker
{
   checkFrequency 1;       // [time steps]
   streamOutput   false;   // Do not use. This will overload the SSD
   vtkOutput      false;

   // OPTIONS
   // checkFrequency     [unsigned integer]; // check frequency [default:0]
   // streamOutput       [boolean]; // output to stream? [default: true]
   // vtkOutput          [boolean]; // output to VTK? [default:true]
   // vtkBaseFolder      [string]; // VTK base folder [default: vtk_out]
   // vtkExecutionFolder [string]; // VTK execution folder [default:output]
   // vtkIdentifier      [string]; // VTK identifier [default: error_field]
   // vtkBinary          [boolean]; // write VTK data in binary? [default: true]
   // vtkLittleEndian    [boolean]; // VTK binary file format [default: true (= little endian)]
   // vtkMPIIO           [boolean]; // use MPI IO for creating VTK output? [default: true]
   // vtkForcePVTU       [boolean]; // force VTK to generate a PVTU file? [default: false]
}

VTK 
{
   // for parameter documentation see src/vtk/Initialization.cpp 
   // or https://www.walberla.net/doxygen/namespacewalberla_1_1vtk.html#a0826685f4bd7089f42a9025d850c3988

   General_settings
   {
      forcePVTU            false;
      continuousNumbering  false;
      binary               true;
      littleEndian         true;
      useMPIIO             false;
      amrFileFormat        false;
   }

   full_domain
   {
      identifier              full_domain;
      writeFrequency          1;      // output frequency = number of times "writeBlocks" must be
                                       // called for triggering an output (optional, default=1)
                                       // 0 disables output
      ghostLayers             0;       // number of ghost layers for vtk output. KEEP EQUAL TO 0 TO PREVENT ERRORS WHEN OPENING VTK                             
      baseFolder              vtk_out;
      executionFolder         simulation_step;
      initialExecutionCount   0;
      startStep 5;

      samplingDxLevel         2; // forces the output to use this dx (= cell x-spacing)
      samplingDyLevel         2; // forces the output to use this dy (= cell y-spacing)
      samplingDzLevel         2; // forces the output to use this dz (= cell z-spacing)
      resolutionLevel < 1, 1, 1 >;
      
      AABBMin < -3, -3, -0.0408125 >;
      AABBMax < 3, 3, 0.0408125 >;
 
   }

   airfoil_proximity
   {
      identifier              airfoil_proximity;
      writeFrequency          1;      // output frequency = number of times "writeBlocks" must be
                                       // called for triggering an output (optional, default=1)
                                       // 0 disables output
      ghostLayers             0;       // number of ghost layers for vtk output. KEEP EQUAL TO 0 TO PREVENT ERRORS WHEN OPENING VTK                            
      baseFolder              vtk_out;
      executionFolder         simulation_step;
      initialExecutionCount   0;
      startStep 8;

      samplingDxLevel         2; // forces the output to use this dx (= cell x-spacing)
      samplingDyLevel         2; // forces the output to use this dy (= cell y-spacing)
      samplingDzLevel         2; // forces the output to use this dz (= cell z-spacing)
      
      AABBMin < -0.2, -0.1, -0.0408125 >;
      AABBMax < 0.4, 0.1, 0.0408125 >;
      resolutionLevel < 2, 2, 2 >;
   }

   }
   

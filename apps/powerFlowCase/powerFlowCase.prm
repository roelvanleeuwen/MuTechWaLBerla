options
{
   writeSetupForestAndReturn false;    // If set to true, the blocks in the domain will be output in a vtk file. The simulation will be terminated after this to save memory
   writeVoxelfile false;               // If set to true, the voxels in the domain will be output in a vtk file. The simulation will be terminated after this to save memory
   writeAirfoilMeshAndReturn false;    // If set true the airfoil stl mesh is written in a vtu file. The simulation will be terminated after this to save memory
   writeSimulationSetupAndUnits true;  // Write the file with the simulation setup and unit conversion

   useTurbulenceModel true;            // Use a turbulence model to simulate the effect of the small unresolved turbulence scales on the larger refined scales (provide stability)
}

flowParameters
{ 
   angleOfAttack 0.0;               // [deg] Physical angle of attack of the flow with respect to the airfoil  
   velocityMagnitudeSI 20;          // [m/s] Physical absolute velocity of the flow
   initialVelocityMagnitudeSI 0; 
   kinViscositySI 1.461e-05;        // [m2/s] Physical kinematic viscosity of the flow
   rhoSI 1.225;                     // [kg/m3] Physical air density
   temperatureSI 288.1;             // [K] Temperature
}

simulationParameters
{
   omega 1.99994;                      // Relaxation factor for the SRT model
   timeSteps   1000;                   // Number of time steps in the simulation
   remainingTimeLoggerFrequency 120;   // in seconds. This is the frequency with which a time estimate of finilising the simulation is send in the terminal. 
   smagorinskyConstant 0.12;           // Smagorinsky constant for the Smagorinky LES turbulence model
}

domainParameters
{
    meshFile         NACA0018.stl;   		      // Object geometry of the airfoil. This must be an ASCII file. If it is binary you should convert it. Also, the mesh must be watertight so no open sides. 
    scalePowerFlowDomain true;          	      // Do you want the full PowerFlow domain. If not, set to false and define an own 'domainScaling'
    decreasePowerFlowDomainFactor 0.142857142; // 0.028571428;  // Set to 1 if the full domain is desired. Change the number of cells in a block accordingly
    dxSI               0.0051015625;            // Unrefined cell size in mm since the airfoil dimensions are in meters
    numLevels        3;                  	      // Number of octree levels starting from 1
    meshZScaling     1;                         // This factor can be used to change the span of the airfoil. The NACA0018 file has a span of 0.081625 which corresponds to a y-scaling of 1
    numGhostLayers   4;                         // Number of ghost layers on each block. Used for communication (overlap) and boundary conditions.

}

spongeZoneParameters
{
   spongeInnerThicknessFactor 0.5;     // inner radius factor of the sponge layer >> r_inner = factor * max(L/2, H/2)
   spongeOuterThicknessFactor 0.75;    // outer radius factor of the sponge layer >> r_outer = factor * max(L/2, H/2)
   sponge_nuT_min 0.0;                 // minimum value of additional numerical viscosity in the sponge layer. This is a factor and multiplied with the base viscosity of the fluid
   sponge_nuT_max 0.5;                 // maximum value of additional numerical viscosity in the sponge layer. This is a factor and multiplied with the base viscosity of the fluid
}

boundaryConditions 
{
   periodicity         <  0, 0, 1 >;       	         // Are there period sides? 0 -> No, 1 -> Yes  For every direction < x, y, z >

   velocity0 < 0.0339296, 0, 0 >;                   // velocity of cells where Velocity0 boundary is set (aoa = 0 deg)
	velocity1 < 0.033909, 0.00118413, 0>;    // velocity of cells where Velocity1 boundary is set (aoa = 2 deg)
	pressure0 1.01;		                           // pressure of cells where Pressure0 boundary is set
	pressure1 1.0;			                           // pressure of cells where Pressure1 boundary is set
    
	Border { direction N,S,W;    walldistance -1;  Velocity0 {} }     // Inflow walls
	Border { direction E;    walldistance -1;  Pressure1 {} }         // Outflow wall

      /* 
      possible sub-blocks: documentation for the subblocks can be found in src/geometry/initializers/BoundaryFrom*.h
         - CellInterval	 BoundaryFromCellInterval.h
         - Border          BoundaryFromDomainBorder.h
         - VoxelFile	     BoundaryFromVoxelFile.h
         - Body			 BoundaryFromBody.h
         - GrayScaleImage  BoundaryFromImage.h
         - RGBAImage	     BoundaryFromImage.h
   */
}

// Parameters for the stability check. If NaN values occur, the simululation is terminated. 
stabilityChecker
{
   checkFrequency 1;       // [time steps]
   streamOutput   false;   // Do not use. This will overload the SSD
   vtkOutput      false;

   // OPTIONS
   // checkFrequency     [unsigned integer]; // check frequency [default:0]
   // streamOutput       [boolean]; // output to stream? [default: true]
   // vtkOutput          [boolean]; // output to VTK? [default:true]
   // vtkBaseFolder      [string]; // VTK base folder [default: vtk_out]
   // vtkExecutionFolder [string]; // VTK execution folder [default:output]
   // vtkIdentifier      [string]; // VTK identifier [default: error_field]
   // vtkBinary          [boolean]; // write VTK data in binary? [default: true]
   // vtkLittleEndian    [boolean]; // VTK binary file format [default: true (= little endian)]
   // vtkMPIIO           [boolean]; // use MPI IO for creating VTK output? [default: true]
   // vtkForcePVTU       [boolean]; // force VTK to generate a PVTU file? [default: false]
}

VTK 
{
   // for parameter documentation see src/vtk/Initialization.cpp 
   // or https://www.walberla.net/doxygen/namespacewalberla_1_1vtk.html#a0826685f4bd7089f42a9025d850c3988
   fluid_field
   {
      writeFrequency 50;           // [time steps] Output a VTK file at writeFrequency
      ghostLayers    4;             // Number of ghostlayers to exclude from the VTK output
      
      vtkBeforFunctions {
         PDFGhostLayerSync;
      }
      
      vtkInclusionFilters {
         DomainFilter;
      }
      
      vtkWriters {
         Velocity;
         Density;
         Omega;
      }

   TE_zone
   {
      simultaneousIOOperations 0;      // max. number of files that are written
                                       // in parallel (optional, default=0 [=disabled])

      initialExecutionCount   0;       // optional, default=0
      initialWriteCallsToSkip 2;       // optional, default=0
      writeFrequency          50;      // output frequency = number of times "writeBlocks" must be
                                       // called for triggering an output (optional, default=1)
                                       // 0 disables output
      forcePVTU               false;   // if true, (P)VTU files are created, and not (P)VTI files
                                       // (optional, default=false)
      ghostLayers             4;       // number of ghost layers (optional, default=0)
 
      baseFolder      vtk_out/TE_zone; // base directory (optional, default=vtk_out)
      executionFolder simulation_step; // base directory for each time step, directory path is given relative
                                       // to baseFolder (optional, default=simulation_step)
 
      outputDomainDecomposition false; // if true, the domain decomposition is written to file
                                       // specifying cell filters and block cell data writers is
                                       // not allowed! (optional, default=false)
      continuousNumbering       true ; // if false, the actual time step is preserved
                                       // (optional, default=false)
      binary                    true ; // if false, ascii files are written (optional, default=true)
      littleEndian              true ; // switch between little and big endianness (optional, default=true)
 
      useMPIIO                  false; // use MPI I/O to write only one file per time step
                                       // (optional, default=true)
 
      // You can either specify "samplingResolution" or "samplingDx", "samplingDy", and "samplingDz"
      samplingResolution [floating point value]; // "samplingResolution VALUE" has the same effect as
                                                 // setting "samplingDx", "samplingDy", and "samplingDz" to VALUE
      samplingDx         [floating point value]; // forces the output to use this dx (= cell x-spacing)
      samplingDy         [floating point value]; // forces the output to use this dy (= cell y-spacing)
      samplingDz         [floating point value]; // forces the output to use this dz (= cell z-spacing)
 
      before_functions // (OPTIONAL, APPLICATION-DEPENDENT!)
      {
         [NameOfTheFirstFunction];   // the mapping of this name to a function pointer/functor is
         [NameOfTheSecondFunction];  // done by the RegisterVTKOutputFunction "registerVTKOutputFunction"
         [...]                       // which must be implemented by the user
      }
 
      // AABB filters are OPTIONAL. AABB filters are sub blocks that must start with "AABB_filter".
      // AABB filters can be selected as either inclusion or exclusion filters. In order to select an
      // AABB filter "AABB_filter_XXX" as inclusion/exclusion filter, its name/identifier (in this
      // example: "AABB_filter_XXX") must be added to the list of inclusion/exclusion filters in
      // the sub block inclusion_filters/inclusion_filters.
 
      AABB_TE_filter
      {
         min < 0.15, -0.05, -0.081625/2 >;
         max < 0.25, 0.05, 0.081625/2 >;
      }
      // AABB_filter_1
      // {
      //    min < [x: floating point value], [y: floating point value], [z: floating point value] >;
      //    max < [x: floating point value], [y: floating point value], [z: floating point value] >;
      // }
      // AABB_filter_2 { ... }
      // AABB_filter_* { ... }
 
      // CellBB filters are OPTIONAL. CellBB filters are sub blocks that must start with "CellBB_filter".
      // CellBB filters can be selected as either inclusion or exclusion filters. In order to select an
      // CellBB filter "CellBB_filter_XXX" as inclusion/exclusion filter, its name/identifier (in this
      // example: "CellBB_filter_XXX") must be added to the list of inclusion/exclusion filters in
      // the sub block inclusion_filters/inclusion_filters.
      // CellBB filters are AABB filters that are defined using discrete (!) global cell coordinates.
 
      CellBB_filter_0
      {
         level [integer value]; // the cell level to which the following coordinates correspond to
                                // (optional, default=0)
         min < [x: integer value], [y: integer value], [z: integer value] >;
         max < [x: integer value], [y: integer value], [z: integer value] >;
      }
      // CellBB_filter_1
      // {
      //    min < [x: integer value], [y: integer value], [z: integer value] >;
      //    max < [x: integer value], [y: integer value], [z: integer value] >;
      // }
      // CellBB_filter_2 { ... }
      // CellBB_filter_* { ... }
 
      // In terms of set theory: all filters listed as inclusion filters are "added" together,
      // resulting in a union of all filters.
 
      inclusion_filters // (OPTIONAL, APPLICATION-DEPENDENT!)
      {
         [NameOfTheFirstFilter];   // the mapping of this name to an inclusion filter is
         [NameOfTheSecondFilter];  // done by the RegisterVTKOutputFunction "registerVTKOutputFunction"
         [...]                     // which must be implemented by the user
 
         // In terms of set theory: combining filters results in an intersection of these filters.
         combine [NameOfAFilter],[NameOfAnotherFilter],[NameOfYetAnotherFilter],[...];
      }
 
      // In terms of set theory: all filters listed as exclusion filters are "added" together,
      // resulting in a union of all filters.
 
      exclusion_filters // (OPTIONAL, APPLICATION-DEPENDENT!)
      {
         [NameOfTheFirstFilter];   // the mapping of this name to an exclusion filter is
         [NameOfTheSecondFilter];  // done by the RegisterVTKOutputFunction "registerVTKOutputFunction"
         [...]                     // which must be implemented by the user
 
         // In terms of set theory: combining filters results in an intersection of these filters.
         combine [NameOfAFilter],[NameOfAnotherFilter],[NameOfYetAnotherFilter],[...];
      }
 
      writers // (AT LEAST ONE IS MANDATORY [exception: if outputDomainDecomposition == true,
              // no writers are allowed!], APPLICATION-DEPENDENT!)
      {
         Velocity;  // the mapping of this name to a writer is
         Density; // done by the RegisterVTKOutputFunction "registerVTKOutputFunction"
         Omega;                    // which must be implemented by the user
      }
 
      requiredGlobalStates      [SUID identifier #1], [SUID identifier #2], ...; // (optional, default=[none])
      incompatibleGlobalStates  [SUID identifier #1], [SUID identifier #2], ...; // (optional, default=[none])
      requiredBlockStates       [SUID identifier #1], [SUID identifier #2], ...; // (optional, default=[none])
      incompatibleBlockStates   [SUID identifier #1], [SUID identifier #2], ...; // (optional, default=[none])
   }   
   }

   }
   
}
